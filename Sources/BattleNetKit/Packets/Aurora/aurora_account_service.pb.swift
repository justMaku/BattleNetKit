// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: aurora/account_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Bgs_Protocol_Account_V1_ResolveAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ref: Bgs_Protocol_Account_V1_AccountReference {
    get {return _storage._ref ?? Bgs_Protocol_Account_V1_AccountReference()}
    set {_uniqueStorage()._ref = newValue}
  }
  /// Returns true if `ref` has been explicitly set.
  public var hasRef: Bool {return _storage._ref != nil}
  /// Clears the value of `ref`. Subsequent reads from it will return its default value.
  public mutating func clearRef() {_uniqueStorage()._ref = nil}

  public var fetchID: Bool {
    get {return _storage._fetchID ?? false}
    set {_uniqueStorage()._fetchID = newValue}
  }
  /// Returns true if `fetchID` has been explicitly set.
  public var hasFetchID: Bool {return _storage._fetchID != nil}
  /// Clears the value of `fetchID`. Subsequent reads from it will return its default value.
  public mutating func clearFetchID() {_uniqueStorage()._fetchID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Bgs_Protocol_Account_V1_ResolveAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Bgs_Protocol_Account_V1_AccountId {
    get {return _storage._id ?? Bgs_Protocol_Account_V1_AccountId()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Bgs_Protocol_Account_V1_GameAccountFlagUpdateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gameAccount: Bgs_Protocol_Account_V1_GameAccountHandle {
    get {return _storage._gameAccount ?? Bgs_Protocol_Account_V1_GameAccountHandle()}
    set {_uniqueStorage()._gameAccount = newValue}
  }
  /// Returns true if `gameAccount` has been explicitly set.
  public var hasGameAccount: Bool {return _storage._gameAccount != nil}
  /// Clears the value of `gameAccount`. Subsequent reads from it will return its default value.
  public mutating func clearGameAccount() {_uniqueStorage()._gameAccount = nil}

  public var flag: UInt64 {
    get {return _storage._flag ?? 0}
    set {_uniqueStorage()._flag = newValue}
  }
  /// Returns true if `flag` has been explicitly set.
  public var hasFlag: Bool {return _storage._flag != nil}
  /// Clears the value of `flag`. Subsequent reads from it will return its default value.
  public mutating func clearFlag() {_uniqueStorage()._flag = nil}

  public var active: Bool {
    get {return _storage._active ?? false}
    set {_uniqueStorage()._active = newValue}
  }
  /// Returns true if `active` has been explicitly set.
  public var hasActive: Bool {return _storage._active != nil}
  /// Clears the value of `active`. Subsequent reads from it will return its default value.
  public mutating func clearActive() {_uniqueStorage()._active = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Bgs_Protocol_Account_V1_SubscriptionUpdateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ref: [Bgs_Protocol_Account_V1_SubscriberReference] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bgs_Protocol_Account_V1_SubscriptionUpdateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ref: [Bgs_Protocol_Account_V1_SubscriberReference] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bgs_Protocol_Account_V1_IsIgrAddressRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clientAddress: String {
    get {return _clientAddress ?? String()}
    set {_clientAddress = newValue}
  }
  /// Returns true if `clientAddress` has been explicitly set.
  public var hasClientAddress: Bool {return self._clientAddress != nil}
  /// Clears the value of `clientAddress`. Subsequent reads from it will return its default value.
  public mutating func clearClientAddress() {self._clientAddress = nil}

  public var region: UInt32 {
    get {return _region ?? 0}
    set {_region = newValue}
  }
  /// Returns true if `region` has been explicitly set.
  public var hasRegion: Bool {return self._region != nil}
  /// Clears the value of `region`. Subsequent reads from it will return its default value.
  public mutating func clearRegion() {self._region = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _clientAddress: String? = nil
  fileprivate var _region: UInt32? = nil
}

public struct Bgs_Protocol_Account_V1_GetAccountStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var entityID: Bgs_Protocol_EntityId {
    get {return _storage._entityID ?? Bgs_Protocol_EntityId()}
    set {_uniqueStorage()._entityID = newValue}
  }
  /// Returns true if `entityID` has been explicitly set.
  public var hasEntityID: Bool {return _storage._entityID != nil}
  /// Clears the value of `entityID`. Subsequent reads from it will return its default value.
  public mutating func clearEntityID() {_uniqueStorage()._entityID = nil}

  public var program: UInt32 {
    get {return _storage._program ?? 0}
    set {_uniqueStorage()._program = newValue}
  }
  /// Returns true if `program` has been explicitly set.
  public var hasProgram: Bool {return _storage._program != nil}
  /// Clears the value of `program`. Subsequent reads from it will return its default value.
  public mutating func clearProgram() {_uniqueStorage()._program = nil}

  public var region: UInt32 {
    get {return _storage._region ?? 0}
    set {_uniqueStorage()._region = newValue}
  }
  /// Returns true if `region` has been explicitly set.
  public var hasRegion: Bool {return _storage._region != nil}
  /// Clears the value of `region`. Subsequent reads from it will return its default value.
  public mutating func clearRegion() {_uniqueStorage()._region = nil}

  public var options: Bgs_Protocol_Account_V1_AccountFieldOptions {
    get {return _storage._options ?? Bgs_Protocol_Account_V1_AccountFieldOptions()}
    set {_uniqueStorage()._options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return _storage._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {_uniqueStorage()._options = nil}

  public var tags: Bgs_Protocol_Account_V1_AccountFieldTags {
    get {return _storage._tags ?? Bgs_Protocol_Account_V1_AccountFieldTags()}
    set {_uniqueStorage()._tags = newValue}
  }
  /// Returns true if `tags` has been explicitly set.
  public var hasTags: Bool {return _storage._tags != nil}
  /// Clears the value of `tags`. Subsequent reads from it will return its default value.
  public mutating func clearTags() {_uniqueStorage()._tags = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Bgs_Protocol_Account_V1_GetAccountStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var state: Bgs_Protocol_Account_V1_AccountState {
    get {return _storage._state ?? Bgs_Protocol_Account_V1_AccountState()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {_uniqueStorage()._state = nil}

  public var tags: Bgs_Protocol_Account_V1_AccountFieldTags {
    get {return _storage._tags ?? Bgs_Protocol_Account_V1_AccountFieldTags()}
    set {_uniqueStorage()._tags = newValue}
  }
  /// Returns true if `tags` has been explicitly set.
  public var hasTags: Bool {return _storage._tags != nil}
  /// Clears the value of `tags`. Subsequent reads from it will return its default value.
  public mutating func clearTags() {_uniqueStorage()._tags = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Bgs_Protocol_Account_V1_GetSignedAccountStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var account: Bgs_Protocol_Account_V1_AccountId {
    get {return _storage._account ?? Bgs_Protocol_Account_V1_AccountId()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {_uniqueStorage()._account = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Bgs_Protocol_Account_V1_GetSignedAccountStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: String {
    get {return _token ?? String()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: String? = nil
}

public struct Bgs_Protocol_Account_V1_GetGameAccountStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var accountID: Bgs_Protocol_EntityId {
    get {return _storage._accountID ?? Bgs_Protocol_EntityId()}
    set {_uniqueStorage()._accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  public var hasAccountID: Bool {return _storage._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  public mutating func clearAccountID() {_uniqueStorage()._accountID = nil}

  public var gameAccountID: Bgs_Protocol_EntityId {
    get {return _storage._gameAccountID ?? Bgs_Protocol_EntityId()}
    set {_uniqueStorage()._gameAccountID = newValue}
  }
  /// Returns true if `gameAccountID` has been explicitly set.
  public var hasGameAccountID: Bool {return _storage._gameAccountID != nil}
  /// Clears the value of `gameAccountID`. Subsequent reads from it will return its default value.
  public mutating func clearGameAccountID() {_uniqueStorage()._gameAccountID = nil}

  public var options: Bgs_Protocol_Account_V1_GameAccountFieldOptions {
    get {return _storage._options ?? Bgs_Protocol_Account_V1_GameAccountFieldOptions()}
    set {_uniqueStorage()._options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return _storage._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {_uniqueStorage()._options = nil}

  public var tags: Bgs_Protocol_Account_V1_GameAccountFieldTags {
    get {return _storage._tags ?? Bgs_Protocol_Account_V1_GameAccountFieldTags()}
    set {_uniqueStorage()._tags = newValue}
  }
  /// Returns true if `tags` has been explicitly set.
  public var hasTags: Bool {return _storage._tags != nil}
  /// Clears the value of `tags`. Subsequent reads from it will return its default value.
  public mutating func clearTags() {_uniqueStorage()._tags = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Bgs_Protocol_Account_V1_GetGameAccountStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var state: Bgs_Protocol_Account_V1_GameAccountState {
    get {return _storage._state ?? Bgs_Protocol_Account_V1_GameAccountState()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {_uniqueStorage()._state = nil}

  public var tags: Bgs_Protocol_Account_V1_GameAccountFieldTags {
    get {return _storage._tags ?? Bgs_Protocol_Account_V1_GameAccountFieldTags()}
    set {_uniqueStorage()._tags = newValue}
  }
  /// Returns true if `tags` has been explicitly set.
  public var hasTags: Bool {return _storage._tags != nil}
  /// Clears the value of `tags`. Subsequent reads from it will return its default value.
  public mutating func clearTags() {_uniqueStorage()._tags = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Bgs_Protocol_Account_V1_GetLicensesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var targetID: Bgs_Protocol_EntityId {
    get {return _storage._targetID ?? Bgs_Protocol_EntityId()}
    set {_uniqueStorage()._targetID = newValue}
  }
  /// Returns true if `targetID` has been explicitly set.
  public var hasTargetID: Bool {return _storage._targetID != nil}
  /// Clears the value of `targetID`. Subsequent reads from it will return its default value.
  public mutating func clearTargetID() {_uniqueStorage()._targetID = nil}

  public var fetchAccountLicenses: Bool {
    get {return _storage._fetchAccountLicenses ?? false}
    set {_uniqueStorage()._fetchAccountLicenses = newValue}
  }
  /// Returns true if `fetchAccountLicenses` has been explicitly set.
  public var hasFetchAccountLicenses: Bool {return _storage._fetchAccountLicenses != nil}
  /// Clears the value of `fetchAccountLicenses`. Subsequent reads from it will return its default value.
  public mutating func clearFetchAccountLicenses() {_uniqueStorage()._fetchAccountLicenses = nil}

  public var fetchGameAccountLicenses: Bool {
    get {return _storage._fetchGameAccountLicenses ?? false}
    set {_uniqueStorage()._fetchGameAccountLicenses = newValue}
  }
  /// Returns true if `fetchGameAccountLicenses` has been explicitly set.
  public var hasFetchGameAccountLicenses: Bool {return _storage._fetchGameAccountLicenses != nil}
  /// Clears the value of `fetchGameAccountLicenses`. Subsequent reads from it will return its default value.
  public mutating func clearFetchGameAccountLicenses() {_uniqueStorage()._fetchGameAccountLicenses = nil}

  public var fetchDynamicAccountLicenses: Bool {
    get {return _storage._fetchDynamicAccountLicenses ?? false}
    set {_uniqueStorage()._fetchDynamicAccountLicenses = newValue}
  }
  /// Returns true if `fetchDynamicAccountLicenses` has been explicitly set.
  public var hasFetchDynamicAccountLicenses: Bool {return _storage._fetchDynamicAccountLicenses != nil}
  /// Clears the value of `fetchDynamicAccountLicenses`. Subsequent reads from it will return its default value.
  public mutating func clearFetchDynamicAccountLicenses() {_uniqueStorage()._fetchDynamicAccountLicenses = nil}

  public var program: UInt32 {
    get {return _storage._program ?? 0}
    set {_uniqueStorage()._program = newValue}
  }
  /// Returns true if `program` has been explicitly set.
  public var hasProgram: Bool {return _storage._program != nil}
  /// Clears the value of `program`. Subsequent reads from it will return its default value.
  public mutating func clearProgram() {_uniqueStorage()._program = nil}

  public var excludeUnknownProgram: Bool {
    get {return _storage._excludeUnknownProgram ?? false}
    set {_uniqueStorage()._excludeUnknownProgram = newValue}
  }
  /// Returns true if `excludeUnknownProgram` has been explicitly set.
  public var hasExcludeUnknownProgram: Bool {return _storage._excludeUnknownProgram != nil}
  /// Clears the value of `excludeUnknownProgram`. Subsequent reads from it will return its default value.
  public mutating func clearExcludeUnknownProgram() {_uniqueStorage()._excludeUnknownProgram = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Bgs_Protocol_Account_V1_GetLicensesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var licenses: [Bgs_Protocol_Account_V1_AccountLicense] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bgs_Protocol_Account_V1_GetGameSessionInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var entityID: Bgs_Protocol_EntityId {
    get {return _storage._entityID ?? Bgs_Protocol_EntityId()}
    set {_uniqueStorage()._entityID = newValue}
  }
  /// Returns true if `entityID` has been explicitly set.
  public var hasEntityID: Bool {return _storage._entityID != nil}
  /// Clears the value of `entityID`. Subsequent reads from it will return its default value.
  public mutating func clearEntityID() {_uniqueStorage()._entityID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Bgs_Protocol_Account_V1_GetGameSessionInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sessionInfo: Bgs_Protocol_Account_V1_GameSessionInfo {
    get {return _storage._sessionInfo ?? Bgs_Protocol_Account_V1_GameSessionInfo()}
    set {_uniqueStorage()._sessionInfo = newValue}
  }
  /// Returns true if `sessionInfo` has been explicitly set.
  public var hasSessionInfo: Bool {return _storage._sessionInfo != nil}
  /// Clears the value of `sessionInfo`. Subsequent reads from it will return its default value.
  public mutating func clearSessionInfo() {_uniqueStorage()._sessionInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Bgs_Protocol_Account_V1_GetGameTimeRemainingInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gameAccountID: Bgs_Protocol_EntityId {
    get {return _storage._gameAccountID ?? Bgs_Protocol_EntityId()}
    set {_uniqueStorage()._gameAccountID = newValue}
  }
  /// Returns true if `gameAccountID` has been explicitly set.
  public var hasGameAccountID: Bool {return _storage._gameAccountID != nil}
  /// Clears the value of `gameAccountID`. Subsequent reads from it will return its default value.
  public mutating func clearGameAccountID() {_uniqueStorage()._gameAccountID = nil}

  public var accountID: Bgs_Protocol_EntityId {
    get {return _storage._accountID ?? Bgs_Protocol_EntityId()}
    set {_uniqueStorage()._accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  public var hasAccountID: Bool {return _storage._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  public mutating func clearAccountID() {_uniqueStorage()._accountID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Bgs_Protocol_Account_V1_GetGameTimeRemainingInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gameTimeRemainingInfo: Bgs_Protocol_Account_V1_GameTimeRemainingInfo {
    get {return _storage._gameTimeRemainingInfo ?? Bgs_Protocol_Account_V1_GameTimeRemainingInfo()}
    set {_uniqueStorage()._gameTimeRemainingInfo = newValue}
  }
  /// Returns true if `gameTimeRemainingInfo` has been explicitly set.
  public var hasGameTimeRemainingInfo: Bool {return _storage._gameTimeRemainingInfo != nil}
  /// Clears the value of `gameTimeRemainingInfo`. Subsequent reads from it will return its default value.
  public mutating func clearGameTimeRemainingInfo() {_uniqueStorage()._gameTimeRemainingInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Bgs_Protocol_Account_V1_GetCAISInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var entityID: Bgs_Protocol_EntityId {
    get {return _storage._entityID ?? Bgs_Protocol_EntityId()}
    set {_uniqueStorage()._entityID = newValue}
  }
  /// Returns true if `entityID` has been explicitly set.
  public var hasEntityID: Bool {return _storage._entityID != nil}
  /// Clears the value of `entityID`. Subsequent reads from it will return its default value.
  public mutating func clearEntityID() {_uniqueStorage()._entityID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Bgs_Protocol_Account_V1_GetCAISInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var caisInfo: Bgs_Protocol_Account_V1_CAIS {
    get {return _storage._caisInfo ?? Bgs_Protocol_Account_V1_CAIS()}
    set {_uniqueStorage()._caisInfo = newValue}
  }
  /// Returns true if `caisInfo` has been explicitly set.
  public var hasCaisInfo: Bool {return _storage._caisInfo != nil}
  /// Clears the value of `caisInfo`. Subsequent reads from it will return its default value.
  public mutating func clearCaisInfo() {_uniqueStorage()._caisInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Bgs_Protocol_Account_V1_GetAuthorizedDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var entityID: Bgs_Protocol_EntityId {
    get {return _storage._entityID ?? Bgs_Protocol_EntityId()}
    set {_uniqueStorage()._entityID = newValue}
  }
  /// Returns true if `entityID` has been explicitly set.
  public var hasEntityID: Bool {return _storage._entityID != nil}
  /// Clears the value of `entityID`. Subsequent reads from it will return its default value.
  public mutating func clearEntityID() {_uniqueStorage()._entityID = nil}

  public var tag: [String] {
    get {return _storage._tag}
    set {_uniqueStorage()._tag = newValue}
  }

  public var privilegedNetwork: Bool {
    get {return _storage._privilegedNetwork ?? false}
    set {_uniqueStorage()._privilegedNetwork = newValue}
  }
  /// Returns true if `privilegedNetwork` has been explicitly set.
  public var hasPrivilegedNetwork: Bool {return _storage._privilegedNetwork != nil}
  /// Clears the value of `privilegedNetwork`. Subsequent reads from it will return its default value.
  public mutating func clearPrivilegedNetwork() {_uniqueStorage()._privilegedNetwork = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Bgs_Protocol_Account_V1_GetAuthorizedDataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: [Bgs_Protocol_Account_V1_AuthorizedData] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bgs_Protocol_Account_V1_AccountStateNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var accountState: Bgs_Protocol_Account_V1_AccountState {
    get {return _storage._accountState ?? Bgs_Protocol_Account_V1_AccountState()}
    set {_uniqueStorage()._accountState = newValue}
  }
  /// Returns true if `accountState` has been explicitly set.
  public var hasAccountState: Bool {return _storage._accountState != nil}
  /// Clears the value of `accountState`. Subsequent reads from it will return its default value.
  public mutating func clearAccountState() {_uniqueStorage()._accountState = nil}

  public var subscriberID: UInt64 {
    get {return _storage._subscriberID ?? 0}
    set {_uniqueStorage()._subscriberID = newValue}
  }
  /// Returns true if `subscriberID` has been explicitly set.
  public var hasSubscriberID: Bool {return _storage._subscriberID != nil}
  /// Clears the value of `subscriberID`. Subsequent reads from it will return its default value.
  public mutating func clearSubscriberID() {_uniqueStorage()._subscriberID = nil}

  public var accountTags: Bgs_Protocol_Account_V1_AccountFieldTags {
    get {return _storage._accountTags ?? Bgs_Protocol_Account_V1_AccountFieldTags()}
    set {_uniqueStorage()._accountTags = newValue}
  }
  /// Returns true if `accountTags` has been explicitly set.
  public var hasAccountTags: Bool {return _storage._accountTags != nil}
  /// Clears the value of `accountTags`. Subsequent reads from it will return its default value.
  public mutating func clearAccountTags() {_uniqueStorage()._accountTags = nil}

  public var subscriptionCompleted: Bool {
    get {return _storage._subscriptionCompleted ?? false}
    set {_uniqueStorage()._subscriptionCompleted = newValue}
  }
  /// Returns true if `subscriptionCompleted` has been explicitly set.
  public var hasSubscriptionCompleted: Bool {return _storage._subscriptionCompleted != nil}
  /// Clears the value of `subscriptionCompleted`. Subsequent reads from it will return its default value.
  public mutating func clearSubscriptionCompleted() {_uniqueStorage()._subscriptionCompleted = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Bgs_Protocol_Account_V1_GameAccountStateNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gameAccountState: Bgs_Protocol_Account_V1_GameAccountState {
    get {return _storage._gameAccountState ?? Bgs_Protocol_Account_V1_GameAccountState()}
    set {_uniqueStorage()._gameAccountState = newValue}
  }
  /// Returns true if `gameAccountState` has been explicitly set.
  public var hasGameAccountState: Bool {return _storage._gameAccountState != nil}
  /// Clears the value of `gameAccountState`. Subsequent reads from it will return its default value.
  public mutating func clearGameAccountState() {_uniqueStorage()._gameAccountState = nil}

  public var subscriberID: UInt64 {
    get {return _storage._subscriberID ?? 0}
    set {_uniqueStorage()._subscriberID = newValue}
  }
  /// Returns true if `subscriberID` has been explicitly set.
  public var hasSubscriberID: Bool {return _storage._subscriberID != nil}
  /// Clears the value of `subscriberID`. Subsequent reads from it will return its default value.
  public mutating func clearSubscriberID() {_uniqueStorage()._subscriberID = nil}

  public var gameAccountTags: Bgs_Protocol_Account_V1_GameAccountFieldTags {
    get {return _storage._gameAccountTags ?? Bgs_Protocol_Account_V1_GameAccountFieldTags()}
    set {_uniqueStorage()._gameAccountTags = newValue}
  }
  /// Returns true if `gameAccountTags` has been explicitly set.
  public var hasGameAccountTags: Bool {return _storage._gameAccountTags != nil}
  /// Clears the value of `gameAccountTags`. Subsequent reads from it will return its default value.
  public mutating func clearGameAccountTags() {_uniqueStorage()._gameAccountTags = nil}

  public var subscriptionCompleted: Bool {
    get {return _storage._subscriptionCompleted ?? false}
    set {_uniqueStorage()._subscriptionCompleted = newValue}
  }
  /// Returns true if `subscriptionCompleted` has been explicitly set.
  public var hasSubscriptionCompleted: Bool {return _storage._subscriptionCompleted != nil}
  /// Clears the value of `subscriptionCompleted`. Subsequent reads from it will return its default value.
  public mutating func clearSubscriptionCompleted() {_uniqueStorage()._subscriptionCompleted = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Bgs_Protocol_Account_V1_GameAccountNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gameAccounts: [Bgs_Protocol_Account_V1_GameAccountList] {
    get {return _storage._gameAccounts}
    set {_uniqueStorage()._gameAccounts = newValue}
  }

  public var subscriberID: UInt64 {
    get {return _storage._subscriberID ?? 0}
    set {_uniqueStorage()._subscriberID = newValue}
  }
  /// Returns true if `subscriberID` has been explicitly set.
  public var hasSubscriberID: Bool {return _storage._subscriberID != nil}
  /// Clears the value of `subscriberID`. Subsequent reads from it will return its default value.
  public mutating func clearSubscriberID() {_uniqueStorage()._subscriberID = nil}

  public var accountTags: Bgs_Protocol_Account_V1_AccountFieldTags {
    get {return _storage._accountTags ?? Bgs_Protocol_Account_V1_AccountFieldTags()}
    set {_uniqueStorage()._accountTags = newValue}
  }
  /// Returns true if `accountTags` has been explicitly set.
  public var hasAccountTags: Bool {return _storage._accountTags != nil}
  /// Clears the value of `accountTags`. Subsequent reads from it will return its default value.
  public mutating func clearAccountTags() {_uniqueStorage()._accountTags = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Bgs_Protocol_Account_V1_GameAccountSessionNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gameAccount: Bgs_Protocol_Account_V1_GameAccountHandle {
    get {return _storage._gameAccount ?? Bgs_Protocol_Account_V1_GameAccountHandle()}
    set {_uniqueStorage()._gameAccount = newValue}
  }
  /// Returns true if `gameAccount` has been explicitly set.
  public var hasGameAccount: Bool {return _storage._gameAccount != nil}
  /// Clears the value of `gameAccount`. Subsequent reads from it will return its default value.
  public mutating func clearGameAccount() {_uniqueStorage()._gameAccount = nil}

  public var sessionInfo: Bgs_Protocol_Account_V1_GameSessionUpdateInfo {
    get {return _storage._sessionInfo ?? Bgs_Protocol_Account_V1_GameSessionUpdateInfo()}
    set {_uniqueStorage()._sessionInfo = newValue}
  }
  /// Returns true if `sessionInfo` has been explicitly set.
  public var hasSessionInfo: Bool {return _storage._sessionInfo != nil}
  /// Clears the value of `sessionInfo`. Subsequent reads from it will return its default value.
  public mutating func clearSessionInfo() {_uniqueStorage()._sessionInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bgs.protocol.account.v1"

extension Bgs_Protocol_Account_V1_ResolveAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResolveAccountRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ref"),
    12: .standard(proto: "fetch_id"),
  ]

  fileprivate class _StorageClass {
    var _ref: Bgs_Protocol_Account_V1_AccountReference? = nil
    var _fetchID: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ref = source._ref
      _fetchID = source._fetchID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._ref, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._ref)
        case 12: try decoder.decodeSingularBoolField(value: &_storage._fetchID)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._ref {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._fetchID {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Account_V1_ResolveAccountRequest, rhs: Bgs_Protocol_Account_V1_ResolveAccountRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ref != rhs_storage._ref {return false}
        if _storage._fetchID != rhs_storage._fetchID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Account_V1_ResolveAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResolveAccountResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    12: .same(proto: "id"),
  ]

  fileprivate class _StorageClass {
    var _id: Bgs_Protocol_Account_V1_AccountId? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._id, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 12: try decoder.decodeSingularMessageField(value: &_storage._id)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Account_V1_ResolveAccountResponse, rhs: Bgs_Protocol_Account_V1_ResolveAccountResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Account_V1_GameAccountFlagUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameAccountFlagUpdateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "game_account"),
    2: .same(proto: "flag"),
    3: .same(proto: "active"),
  ]

  fileprivate class _StorageClass {
    var _gameAccount: Bgs_Protocol_Account_V1_GameAccountHandle? = nil
    var _flag: UInt64? = nil
    var _active: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _gameAccount = source._gameAccount
      _flag = source._flag
      _active = source._active
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._gameAccount, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._gameAccount)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._flag)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._active)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._gameAccount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._flag {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
      }
      if let v = _storage._active {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Account_V1_GameAccountFlagUpdateRequest, rhs: Bgs_Protocol_Account_V1_GameAccountFlagUpdateRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._gameAccount != rhs_storage._gameAccount {return false}
        if _storage._flag != rhs_storage._flag {return false}
        if _storage._active != rhs_storage._active {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Account_V1_SubscriptionUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscriptionUpdateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "ref"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.ref) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeRepeatedMessageField(value: &self.ref)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ref.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ref, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Account_V1_SubscriptionUpdateRequest, rhs: Bgs_Protocol_Account_V1_SubscriptionUpdateRequest) -> Bool {
    if lhs.ref != rhs.ref {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Account_V1_SubscriptionUpdateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscriptionUpdateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ref"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.ref) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.ref)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ref.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ref, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Account_V1_SubscriptionUpdateResponse, rhs: Bgs_Protocol_Account_V1_SubscriptionUpdateResponse) -> Bool {
    if lhs.ref != rhs.ref {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Account_V1_IsIgrAddressRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IsIgrAddressRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_address"),
    2: .same(proto: "region"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._clientAddress)
      case 2: try decoder.decodeSingularUInt32Field(value: &self._region)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._clientAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._region {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Account_V1_IsIgrAddressRequest, rhs: Bgs_Protocol_Account_V1_IsIgrAddressRequest) -> Bool {
    if lhs._clientAddress != rhs._clientAddress {return false}
    if lhs._region != rhs._region {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Account_V1_GetAccountStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAccountStateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entity_id"),
    2: .same(proto: "program"),
    3: .same(proto: "region"),
    10: .same(proto: "options"),
    11: .same(proto: "tags"),
  ]

  fileprivate class _StorageClass {
    var _entityID: Bgs_Protocol_EntityId? = nil
    var _program: UInt32? = nil
    var _region: UInt32? = nil
    var _options: Bgs_Protocol_Account_V1_AccountFieldOptions? = nil
    var _tags: Bgs_Protocol_Account_V1_AccountFieldTags? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _entityID = source._entityID
      _program = source._program
      _region = source._region
      _options = source._options
      _tags = source._tags
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._entityID, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._entityID)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._program)
        case 3: try decoder.decodeSingularUInt32Field(value: &_storage._region)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._options)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._tags)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._entityID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._program {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      }
      if let v = _storage._region {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      }
      if let v = _storage._options {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._tags {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Account_V1_GetAccountStateRequest, rhs: Bgs_Protocol_Account_V1_GetAccountStateRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._entityID != rhs_storage._entityID {return false}
        if _storage._program != rhs_storage._program {return false}
        if _storage._region != rhs_storage._region {return false}
        if _storage._options != rhs_storage._options {return false}
        if _storage._tags != rhs_storage._tags {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Account_V1_GetAccountStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAccountStateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .same(proto: "tags"),
  ]

  fileprivate class _StorageClass {
    var _state: Bgs_Protocol_Account_V1_AccountState? = nil
    var _tags: Bgs_Protocol_Account_V1_AccountFieldTags? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _state = source._state
      _tags = source._tags
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._state, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._state)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._tags)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._tags {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Account_V1_GetAccountStateResponse, rhs: Bgs_Protocol_Account_V1_GetAccountStateResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._state != rhs_storage._state {return false}
        if _storage._tags != rhs_storage._tags {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Account_V1_GetSignedAccountStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSignedAccountStateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
  ]

  fileprivate class _StorageClass {
    var _account: Bgs_Protocol_Account_V1_AccountId? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._account, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._account)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Account_V1_GetSignedAccountStateRequest, rhs: Bgs_Protocol_Account_V1_GetSignedAccountStateRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._account != rhs_storage._account {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Account_V1_GetSignedAccountStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSignedAccountStateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._token)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._token {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Account_V1_GetSignedAccountStateResponse, rhs: Bgs_Protocol_Account_V1_GetSignedAccountStateResponse) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Account_V1_GetGameAccountStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGameAccountStateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
    2: .standard(proto: "game_account_id"),
    10: .same(proto: "options"),
    11: .same(proto: "tags"),
  ]

  fileprivate class _StorageClass {
    var _accountID: Bgs_Protocol_EntityId? = nil
    var _gameAccountID: Bgs_Protocol_EntityId? = nil
    var _options: Bgs_Protocol_Account_V1_GameAccountFieldOptions? = nil
    var _tags: Bgs_Protocol_Account_V1_GameAccountFieldTags? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _accountID = source._accountID
      _gameAccountID = source._gameAccountID
      _options = source._options
      _tags = source._tags
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._accountID, !v.isInitialized {return false}
      if let v = _storage._gameAccountID, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._accountID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._gameAccountID)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._options)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._tags)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._accountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._gameAccountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._options {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._tags {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Account_V1_GetGameAccountStateRequest, rhs: Bgs_Protocol_Account_V1_GetGameAccountStateRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._accountID != rhs_storage._accountID {return false}
        if _storage._gameAccountID != rhs_storage._gameAccountID {return false}
        if _storage._options != rhs_storage._options {return false}
        if _storage._tags != rhs_storage._tags {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Account_V1_GetGameAccountStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGameAccountStateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .same(proto: "tags"),
  ]

  fileprivate class _StorageClass {
    var _state: Bgs_Protocol_Account_V1_GameAccountState? = nil
    var _tags: Bgs_Protocol_Account_V1_GameAccountFieldTags? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _state = source._state
      _tags = source._tags
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._state, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._state)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._tags)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._tags {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Account_V1_GetGameAccountStateResponse, rhs: Bgs_Protocol_Account_V1_GetGameAccountStateResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._state != rhs_storage._state {return false}
        if _storage._tags != rhs_storage._tags {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Account_V1_GetLicensesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLicensesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_id"),
    2: .standard(proto: "fetch_account_licenses"),
    3: .standard(proto: "fetch_game_account_licenses"),
    4: .standard(proto: "fetch_dynamic_account_licenses"),
    5: .same(proto: "program"),
    6: .standard(proto: "exclude_unknown_program"),
  ]

  fileprivate class _StorageClass {
    var _targetID: Bgs_Protocol_EntityId? = nil
    var _fetchAccountLicenses: Bool? = nil
    var _fetchGameAccountLicenses: Bool? = nil
    var _fetchDynamicAccountLicenses: Bool? = nil
    var _program: UInt32? = nil
    var _excludeUnknownProgram: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _targetID = source._targetID
      _fetchAccountLicenses = source._fetchAccountLicenses
      _fetchGameAccountLicenses = source._fetchGameAccountLicenses
      _fetchDynamicAccountLicenses = source._fetchDynamicAccountLicenses
      _program = source._program
      _excludeUnknownProgram = source._excludeUnknownProgram
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._targetID, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._targetID)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._fetchAccountLicenses)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._fetchGameAccountLicenses)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._fetchDynamicAccountLicenses)
        case 5: try decoder.decodeSingularFixed32Field(value: &_storage._program)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._excludeUnknownProgram)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._targetID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._fetchAccountLicenses {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      }
      if let v = _storage._fetchGameAccountLicenses {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      }
      if let v = _storage._fetchDynamicAccountLicenses {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      }
      if let v = _storage._program {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
      }
      if let v = _storage._excludeUnknownProgram {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Account_V1_GetLicensesRequest, rhs: Bgs_Protocol_Account_V1_GetLicensesRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._targetID != rhs_storage._targetID {return false}
        if _storage._fetchAccountLicenses != rhs_storage._fetchAccountLicenses {return false}
        if _storage._fetchGameAccountLicenses != rhs_storage._fetchGameAccountLicenses {return false}
        if _storage._fetchDynamicAccountLicenses != rhs_storage._fetchDynamicAccountLicenses {return false}
        if _storage._program != rhs_storage._program {return false}
        if _storage._excludeUnknownProgram != rhs_storage._excludeUnknownProgram {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Account_V1_GetLicensesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLicensesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "licenses"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.licenses) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.licenses)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.licenses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.licenses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Account_V1_GetLicensesResponse, rhs: Bgs_Protocol_Account_V1_GetLicensesResponse) -> Bool {
    if lhs.licenses != rhs.licenses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Account_V1_GetGameSessionInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGameSessionInfoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entity_id"),
  ]

  fileprivate class _StorageClass {
    var _entityID: Bgs_Protocol_EntityId? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _entityID = source._entityID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._entityID, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._entityID)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._entityID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Account_V1_GetGameSessionInfoRequest, rhs: Bgs_Protocol_Account_V1_GetGameSessionInfoRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._entityID != rhs_storage._entityID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Account_V1_GetGameSessionInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGameSessionInfoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "session_info"),
  ]

  fileprivate class _StorageClass {
    var _sessionInfo: Bgs_Protocol_Account_V1_GameSessionInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sessionInfo = source._sessionInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._sessionInfo, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 2: try decoder.decodeSingularMessageField(value: &_storage._sessionInfo)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._sessionInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Account_V1_GetGameSessionInfoResponse, rhs: Bgs_Protocol_Account_V1_GetGameSessionInfoResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sessionInfo != rhs_storage._sessionInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Account_V1_GetGameTimeRemainingInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGameTimeRemainingInfoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "game_account_id"),
    2: .standard(proto: "account_id"),
  ]

  fileprivate class _StorageClass {
    var _gameAccountID: Bgs_Protocol_EntityId? = nil
    var _accountID: Bgs_Protocol_EntityId? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _gameAccountID = source._gameAccountID
      _accountID = source._accountID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._gameAccountID, !v.isInitialized {return false}
      if let v = _storage._accountID, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._gameAccountID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._accountID)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._gameAccountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._accountID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Account_V1_GetGameTimeRemainingInfoRequest, rhs: Bgs_Protocol_Account_V1_GetGameTimeRemainingInfoRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._gameAccountID != rhs_storage._gameAccountID {return false}
        if _storage._accountID != rhs_storage._accountID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Account_V1_GetGameTimeRemainingInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGameTimeRemainingInfoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "game_time_remaining_info"),
  ]

  fileprivate class _StorageClass {
    var _gameTimeRemainingInfo: Bgs_Protocol_Account_V1_GameTimeRemainingInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _gameTimeRemainingInfo = source._gameTimeRemainingInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._gameTimeRemainingInfo)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._gameTimeRemainingInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Account_V1_GetGameTimeRemainingInfoResponse, rhs: Bgs_Protocol_Account_V1_GetGameTimeRemainingInfoResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._gameTimeRemainingInfo != rhs_storage._gameTimeRemainingInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Account_V1_GetCAISInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCAISInfoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entity_id"),
  ]

  fileprivate class _StorageClass {
    var _entityID: Bgs_Protocol_EntityId? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _entityID = source._entityID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._entityID, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._entityID)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._entityID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Account_V1_GetCAISInfoRequest, rhs: Bgs_Protocol_Account_V1_GetCAISInfoRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._entityID != rhs_storage._entityID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Account_V1_GetCAISInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCAISInfoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cais_info"),
  ]

  fileprivate class _StorageClass {
    var _caisInfo: Bgs_Protocol_Account_V1_CAIS? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _caisInfo = source._caisInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._caisInfo)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._caisInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Account_V1_GetCAISInfoResponse, rhs: Bgs_Protocol_Account_V1_GetCAISInfoResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._caisInfo != rhs_storage._caisInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Account_V1_GetAuthorizedDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAuthorizedDataRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entity_id"),
    2: .same(proto: "tag"),
    3: .standard(proto: "privileged_network"),
  ]

  fileprivate class _StorageClass {
    var _entityID: Bgs_Protocol_EntityId? = nil
    var _tag: [String] = []
    var _privilegedNetwork: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _entityID = source._entityID
      _tag = source._tag
      _privilegedNetwork = source._privilegedNetwork
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._entityID, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._entityID)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._tag)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._privilegedNetwork)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._entityID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._tag.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._tag, fieldNumber: 2)
      }
      if let v = _storage._privilegedNetwork {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Account_V1_GetAuthorizedDataRequest, rhs: Bgs_Protocol_Account_V1_GetAuthorizedDataRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._entityID != rhs_storage._entityID {return false}
        if _storage._tag != rhs_storage._tag {return false}
        if _storage._privilegedNetwork != rhs_storage._privilegedNetwork {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Account_V1_GetAuthorizedDataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAuthorizedDataResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.data)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Account_V1_GetAuthorizedDataResponse, rhs: Bgs_Protocol_Account_V1_GetAuthorizedDataResponse) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Account_V1_AccountStateNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountStateNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_state"),
    2: .standard(proto: "subscriber_id"),
    3: .standard(proto: "account_tags"),
    4: .standard(proto: "subscription_completed"),
  ]

  fileprivate class _StorageClass {
    var _accountState: Bgs_Protocol_Account_V1_AccountState? = nil
    var _subscriberID: UInt64? = nil
    var _accountTags: Bgs_Protocol_Account_V1_AccountFieldTags? = nil
    var _subscriptionCompleted: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _accountState = source._accountState
      _subscriberID = source._subscriberID
      _accountTags = source._accountTags
      _subscriptionCompleted = source._subscriptionCompleted
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._accountState, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._accountState)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._subscriberID)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._accountTags)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._subscriptionCompleted)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._accountState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._subscriberID {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
      }
      if let v = _storage._accountTags {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._subscriptionCompleted {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Account_V1_AccountStateNotification, rhs: Bgs_Protocol_Account_V1_AccountStateNotification) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._accountState != rhs_storage._accountState {return false}
        if _storage._subscriberID != rhs_storage._subscriberID {return false}
        if _storage._accountTags != rhs_storage._accountTags {return false}
        if _storage._subscriptionCompleted != rhs_storage._subscriptionCompleted {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Account_V1_GameAccountStateNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameAccountStateNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "game_account_state"),
    2: .standard(proto: "subscriber_id"),
    3: .standard(proto: "game_account_tags"),
    4: .standard(proto: "subscription_completed"),
  ]

  fileprivate class _StorageClass {
    var _gameAccountState: Bgs_Protocol_Account_V1_GameAccountState? = nil
    var _subscriberID: UInt64? = nil
    var _gameAccountTags: Bgs_Protocol_Account_V1_GameAccountFieldTags? = nil
    var _subscriptionCompleted: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _gameAccountState = source._gameAccountState
      _subscriberID = source._subscriberID
      _gameAccountTags = source._gameAccountTags
      _subscriptionCompleted = source._subscriptionCompleted
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._gameAccountState, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._gameAccountState)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._subscriberID)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._gameAccountTags)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._subscriptionCompleted)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._gameAccountState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._subscriberID {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
      }
      if let v = _storage._gameAccountTags {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._subscriptionCompleted {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Account_V1_GameAccountStateNotification, rhs: Bgs_Protocol_Account_V1_GameAccountStateNotification) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._gameAccountState != rhs_storage._gameAccountState {return false}
        if _storage._subscriberID != rhs_storage._subscriberID {return false}
        if _storage._gameAccountTags != rhs_storage._gameAccountTags {return false}
        if _storage._subscriptionCompleted != rhs_storage._subscriptionCompleted {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Account_V1_GameAccountNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameAccountNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "game_accounts"),
    2: .standard(proto: "subscriber_id"),
    3: .standard(proto: "account_tags"),
  ]

  fileprivate class _StorageClass {
    var _gameAccounts: [Bgs_Protocol_Account_V1_GameAccountList] = []
    var _subscriberID: UInt64? = nil
    var _accountTags: Bgs_Protocol_Account_V1_AccountFieldTags? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _gameAccounts = source._gameAccounts
      _subscriberID = source._subscriberID
      _accountTags = source._accountTags
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._gameAccounts) {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._gameAccounts)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._subscriberID)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._accountTags)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._gameAccounts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._gameAccounts, fieldNumber: 1)
      }
      if let v = _storage._subscriberID {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
      }
      if let v = _storage._accountTags {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Account_V1_GameAccountNotification, rhs: Bgs_Protocol_Account_V1_GameAccountNotification) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._gameAccounts != rhs_storage._gameAccounts {return false}
        if _storage._subscriberID != rhs_storage._subscriberID {return false}
        if _storage._accountTags != rhs_storage._accountTags {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Account_V1_GameAccountSessionNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameAccountSessionNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "game_account"),
    2: .standard(proto: "session_info"),
  ]

  fileprivate class _StorageClass {
    var _gameAccount: Bgs_Protocol_Account_V1_GameAccountHandle? = nil
    var _sessionInfo: Bgs_Protocol_Account_V1_GameSessionUpdateInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _gameAccount = source._gameAccount
      _sessionInfo = source._sessionInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._gameAccount, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._gameAccount)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._sessionInfo)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._gameAccount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._sessionInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Account_V1_GameAccountSessionNotification, rhs: Bgs_Protocol_Account_V1_GameAccountSessionNotification) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._gameAccount != rhs_storage._gameAccount {return false}
        if _storage._sessionInfo != rhs_storage._sessionInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
