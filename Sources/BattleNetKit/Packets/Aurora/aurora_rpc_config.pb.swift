// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: aurora/rpc_config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Bgs_Protocol_Config_RPCMethodConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var serviceName: String {
    get {return _serviceName ?? String()}
    set {_serviceName = newValue}
  }
  /// Returns true if `serviceName` has been explicitly set.
  public var hasServiceName: Bool {return self._serviceName != nil}
  /// Clears the value of `serviceName`. Subsequent reads from it will return its default value.
  public mutating func clearServiceName() {self._serviceName = nil}

  public var methodName: String {
    get {return _methodName ?? String()}
    set {_methodName = newValue}
  }
  /// Returns true if `methodName` has been explicitly set.
  public var hasMethodName: Bool {return self._methodName != nil}
  /// Clears the value of `methodName`. Subsequent reads from it will return its default value.
  public mutating func clearMethodName() {self._methodName = nil}

  public var fixedCallCost: UInt32 {
    get {return _fixedCallCost ?? 1}
    set {_fixedCallCost = newValue}
  }
  /// Returns true if `fixedCallCost` has been explicitly set.
  public var hasFixedCallCost: Bool {return self._fixedCallCost != nil}
  /// Clears the value of `fixedCallCost`. Subsequent reads from it will return its default value.
  public mutating func clearFixedCallCost() {self._fixedCallCost = nil}

  public var fixedPacketSize: UInt32 {
    get {return _fixedPacketSize ?? 0}
    set {_fixedPacketSize = newValue}
  }
  /// Returns true if `fixedPacketSize` has been explicitly set.
  public var hasFixedPacketSize: Bool {return self._fixedPacketSize != nil}
  /// Clears the value of `fixedPacketSize`. Subsequent reads from it will return its default value.
  public mutating func clearFixedPacketSize() {self._fixedPacketSize = nil}

  public var variableMultiplier: Float {
    get {return _variableMultiplier ?? 0}
    set {_variableMultiplier = newValue}
  }
  /// Returns true if `variableMultiplier` has been explicitly set.
  public var hasVariableMultiplier: Bool {return self._variableMultiplier != nil}
  /// Clears the value of `variableMultiplier`. Subsequent reads from it will return its default value.
  public mutating func clearVariableMultiplier() {self._variableMultiplier = nil}

  public var multiplier: Float {
    get {return _multiplier ?? 1}
    set {_multiplier = newValue}
  }
  /// Returns true if `multiplier` has been explicitly set.
  public var hasMultiplier: Bool {return self._multiplier != nil}
  /// Clears the value of `multiplier`. Subsequent reads from it will return its default value.
  public mutating func clearMultiplier() {self._multiplier = nil}

  public var rateLimitCount: UInt32 {
    get {return _rateLimitCount ?? 0}
    set {_rateLimitCount = newValue}
  }
  /// Returns true if `rateLimitCount` has been explicitly set.
  public var hasRateLimitCount: Bool {return self._rateLimitCount != nil}
  /// Clears the value of `rateLimitCount`. Subsequent reads from it will return its default value.
  public mutating func clearRateLimitCount() {self._rateLimitCount = nil}

  public var rateLimitSeconds: UInt32 {
    get {return _rateLimitSeconds ?? 0}
    set {_rateLimitSeconds = newValue}
  }
  /// Returns true if `rateLimitSeconds` has been explicitly set.
  public var hasRateLimitSeconds: Bool {return self._rateLimitSeconds != nil}
  /// Clears the value of `rateLimitSeconds`. Subsequent reads from it will return its default value.
  public mutating func clearRateLimitSeconds() {self._rateLimitSeconds = nil}

  public var maxPacketSize: UInt32 {
    get {return _maxPacketSize ?? 0}
    set {_maxPacketSize = newValue}
  }
  /// Returns true if `maxPacketSize` has been explicitly set.
  public var hasMaxPacketSize: Bool {return self._maxPacketSize != nil}
  /// Clears the value of `maxPacketSize`. Subsequent reads from it will return its default value.
  public mutating func clearMaxPacketSize() {self._maxPacketSize = nil}

  public var maxEncodedSize: UInt32 {
    get {return _maxEncodedSize ?? 0}
    set {_maxEncodedSize = newValue}
  }
  /// Returns true if `maxEncodedSize` has been explicitly set.
  public var hasMaxEncodedSize: Bool {return self._maxEncodedSize != nil}
  /// Clears the value of `maxEncodedSize`. Subsequent reads from it will return its default value.
  public mutating func clearMaxEncodedSize() {self._maxEncodedSize = nil}

  public var timeout: Float {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  public var hasTimeout: Bool {return self._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  public mutating func clearTimeout() {self._timeout = nil}

  public var capBalance: UInt32 {
    get {return _capBalance ?? 0}
    set {_capBalance = newValue}
  }
  /// Returns true if `capBalance` has been explicitly set.
  public var hasCapBalance: Bool {return self._capBalance != nil}
  /// Clears the value of `capBalance`. Subsequent reads from it will return its default value.
  public mutating func clearCapBalance() {self._capBalance = nil}

  public var incomePerSecond: Float {
    get {return _incomePerSecond ?? 0}
    set {_incomePerSecond = newValue}
  }
  /// Returns true if `incomePerSecond` has been explicitly set.
  public var hasIncomePerSecond: Bool {return self._incomePerSecond != nil}
  /// Clears the value of `incomePerSecond`. Subsequent reads from it will return its default value.
  public mutating func clearIncomePerSecond() {self._incomePerSecond = nil}

  public var serviceHash: UInt32 {
    get {return _serviceHash ?? 0}
    set {_serviceHash = newValue}
  }
  /// Returns true if `serviceHash` has been explicitly set.
  public var hasServiceHash: Bool {return self._serviceHash != nil}
  /// Clears the value of `serviceHash`. Subsequent reads from it will return its default value.
  public mutating func clearServiceHash() {self._serviceHash = nil}

  public var methodID: UInt32 {
    get {return _methodID ?? 0}
    set {_methodID = newValue}
  }
  /// Returns true if `methodID` has been explicitly set.
  public var hasMethodID: Bool {return self._methodID != nil}
  /// Clears the value of `methodID`. Subsequent reads from it will return its default value.
  public mutating func clearMethodID() {self._methodID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _serviceName: String? = nil
  fileprivate var _methodName: String? = nil
  fileprivate var _fixedCallCost: UInt32? = nil
  fileprivate var _fixedPacketSize: UInt32? = nil
  fileprivate var _variableMultiplier: Float? = nil
  fileprivate var _multiplier: Float? = nil
  fileprivate var _rateLimitCount: UInt32? = nil
  fileprivate var _rateLimitSeconds: UInt32? = nil
  fileprivate var _maxPacketSize: UInt32? = nil
  fileprivate var _maxEncodedSize: UInt32? = nil
  fileprivate var _timeout: Float? = nil
  fileprivate var _capBalance: UInt32? = nil
  fileprivate var _incomePerSecond: Float? = nil
  fileprivate var _serviceHash: UInt32? = nil
  fileprivate var _methodID: UInt32? = nil
}

public struct Bgs_Protocol_Config_RPCMeterConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var method: [Bgs_Protocol_Config_RPCMethodConfig] = []

  public var incomePerSecond: UInt32 {
    get {return _incomePerSecond ?? 1}
    set {_incomePerSecond = newValue}
  }
  /// Returns true if `incomePerSecond` has been explicitly set.
  public var hasIncomePerSecond: Bool {return self._incomePerSecond != nil}
  /// Clears the value of `incomePerSecond`. Subsequent reads from it will return its default value.
  public mutating func clearIncomePerSecond() {self._incomePerSecond = nil}

  public var initialBalance: UInt32 {
    get {return _initialBalance ?? 0}
    set {_initialBalance = newValue}
  }
  /// Returns true if `initialBalance` has been explicitly set.
  public var hasInitialBalance: Bool {return self._initialBalance != nil}
  /// Clears the value of `initialBalance`. Subsequent reads from it will return its default value.
  public mutating func clearInitialBalance() {self._initialBalance = nil}

  public var capBalance: UInt32 {
    get {return _capBalance ?? 0}
    set {_capBalance = newValue}
  }
  /// Returns true if `capBalance` has been explicitly set.
  public var hasCapBalance: Bool {return self._capBalance != nil}
  /// Clears the value of `capBalance`. Subsequent reads from it will return its default value.
  public mutating func clearCapBalance() {self._capBalance = nil}

  public var startupPeriod: Float {
    get {return _startupPeriod ?? 0}
    set {_startupPeriod = newValue}
  }
  /// Returns true if `startupPeriod` has been explicitly set.
  public var hasStartupPeriod: Bool {return self._startupPeriod != nil}
  /// Clears the value of `startupPeriod`. Subsequent reads from it will return its default value.
  public mutating func clearStartupPeriod() {self._startupPeriod = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _incomePerSecond: UInt32? = nil
  fileprivate var _initialBalance: UInt32? = nil
  fileprivate var _capBalance: UInt32? = nil
  fileprivate var _startupPeriod: Float? = nil
}

public struct Bgs_Protocol_Config_ProtocolAlias {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var serverServiceName: String {
    get {return _serverServiceName ?? String()}
    set {_serverServiceName = newValue}
  }
  /// Returns true if `serverServiceName` has been explicitly set.
  public var hasServerServiceName: Bool {return self._serverServiceName != nil}
  /// Clears the value of `serverServiceName`. Subsequent reads from it will return its default value.
  public mutating func clearServerServiceName() {self._serverServiceName = nil}

  public var clientServiceName: String {
    get {return _clientServiceName ?? String()}
    set {_clientServiceName = newValue}
  }
  /// Returns true if `clientServiceName` has been explicitly set.
  public var hasClientServiceName: Bool {return self._clientServiceName != nil}
  /// Clears the value of `clientServiceName`. Subsequent reads from it will return its default value.
  public mutating func clearClientServiceName() {self._clientServiceName = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _serverServiceName: String? = nil
  fileprivate var _clientServiceName: String? = nil
}

public struct Bgs_Protocol_Config_ServiceAliases {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var protocolAlias: [Bgs_Protocol_Config_ProtocolAlias] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bgs.protocol.config"

extension Bgs_Protocol_Config_RPCMethodConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RPCMethodConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "service_name"),
    2: .standard(proto: "method_name"),
    3: .standard(proto: "fixed_call_cost"),
    4: .standard(proto: "fixed_packet_size"),
    5: .standard(proto: "variable_multiplier"),
    6: .same(proto: "multiplier"),
    7: .standard(proto: "rate_limit_count"),
    8: .standard(proto: "rate_limit_seconds"),
    9: .standard(proto: "max_packet_size"),
    10: .standard(proto: "max_encoded_size"),
    11: .same(proto: "timeout"),
    12: .standard(proto: "cap_balance"),
    13: .standard(proto: "income_per_second"),
    14: .standard(proto: "service_hash"),
    15: .standard(proto: "method_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._serviceName)
      case 2: try decoder.decodeSingularStringField(value: &self._methodName)
      case 3: try decoder.decodeSingularUInt32Field(value: &self._fixedCallCost)
      case 4: try decoder.decodeSingularUInt32Field(value: &self._fixedPacketSize)
      case 5: try decoder.decodeSingularFloatField(value: &self._variableMultiplier)
      case 6: try decoder.decodeSingularFloatField(value: &self._multiplier)
      case 7: try decoder.decodeSingularUInt32Field(value: &self._rateLimitCount)
      case 8: try decoder.decodeSingularUInt32Field(value: &self._rateLimitSeconds)
      case 9: try decoder.decodeSingularUInt32Field(value: &self._maxPacketSize)
      case 10: try decoder.decodeSingularUInt32Field(value: &self._maxEncodedSize)
      case 11: try decoder.decodeSingularFloatField(value: &self._timeout)
      case 12: try decoder.decodeSingularUInt32Field(value: &self._capBalance)
      case 13: try decoder.decodeSingularFloatField(value: &self._incomePerSecond)
      case 14: try decoder.decodeSingularUInt32Field(value: &self._serviceHash)
      case 15: try decoder.decodeSingularUInt32Field(value: &self._methodID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._serviceName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._methodName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._fixedCallCost {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._fixedPacketSize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._variableMultiplier {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    }
    if let v = self._multiplier {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 6)
    }
    if let v = self._rateLimitCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._rateLimitSeconds {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    }
    if let v = self._maxPacketSize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    }
    if let v = self._maxEncodedSize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    }
    if let v = self._timeout {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 11)
    }
    if let v = self._capBalance {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 12)
    }
    if let v = self._incomePerSecond {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 13)
    }
    if let v = self._serviceHash {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 14)
    }
    if let v = self._methodID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Config_RPCMethodConfig, rhs: Bgs_Protocol_Config_RPCMethodConfig) -> Bool {
    if lhs._serviceName != rhs._serviceName {return false}
    if lhs._methodName != rhs._methodName {return false}
    if lhs._fixedCallCost != rhs._fixedCallCost {return false}
    if lhs._fixedPacketSize != rhs._fixedPacketSize {return false}
    if lhs._variableMultiplier != rhs._variableMultiplier {return false}
    if lhs._multiplier != rhs._multiplier {return false}
    if lhs._rateLimitCount != rhs._rateLimitCount {return false}
    if lhs._rateLimitSeconds != rhs._rateLimitSeconds {return false}
    if lhs._maxPacketSize != rhs._maxPacketSize {return false}
    if lhs._maxEncodedSize != rhs._maxEncodedSize {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs._capBalance != rhs._capBalance {return false}
    if lhs._incomePerSecond != rhs._incomePerSecond {return false}
    if lhs._serviceHash != rhs._serviceHash {return false}
    if lhs._methodID != rhs._methodID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Config_RPCMeterConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RPCMeterConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "method"),
    2: .standard(proto: "income_per_second"),
    3: .standard(proto: "initial_balance"),
    4: .standard(proto: "cap_balance"),
    5: .standard(proto: "startup_period"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.method)
      case 2: try decoder.decodeSingularUInt32Field(value: &self._incomePerSecond)
      case 3: try decoder.decodeSingularUInt32Field(value: &self._initialBalance)
      case 4: try decoder.decodeSingularUInt32Field(value: &self._capBalance)
      case 5: try decoder.decodeSingularFloatField(value: &self._startupPeriod)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.method.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.method, fieldNumber: 1)
    }
    if let v = self._incomePerSecond {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._initialBalance {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._capBalance {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._startupPeriod {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Config_RPCMeterConfig, rhs: Bgs_Protocol_Config_RPCMeterConfig) -> Bool {
    if lhs.method != rhs.method {return false}
    if lhs._incomePerSecond != rhs._incomePerSecond {return false}
    if lhs._initialBalance != rhs._initialBalance {return false}
    if lhs._capBalance != rhs._capBalance {return false}
    if lhs._startupPeriod != rhs._startupPeriod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Config_ProtocolAlias: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProtocolAlias"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_service_name"),
    2: .standard(proto: "client_service_name"),
  ]

  public var isInitialized: Bool {
    if self._serverServiceName == nil {return false}
    if self._clientServiceName == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._serverServiceName)
      case 2: try decoder.decodeSingularStringField(value: &self._clientServiceName)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._serverServiceName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._clientServiceName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Config_ProtocolAlias, rhs: Bgs_Protocol_Config_ProtocolAlias) -> Bool {
    if lhs._serverServiceName != rhs._serverServiceName {return false}
    if lhs._clientServiceName != rhs._clientServiceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_Config_ServiceAliases: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServiceAliases"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "protocol_alias"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.protocolAlias) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.protocolAlias)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.protocolAlias.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.protocolAlias, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_Config_ServiceAliases, rhs: Bgs_Protocol_Config_ServiceAliases) -> Bool {
    if lhs.protocolAlias != rhs.protocolAlias {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
