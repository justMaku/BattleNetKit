// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: aurora/global_extensions/field_options.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Bgs_Protocol_LogOption: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case hidden // = 1
  case hex // = 2

  public init() {
    self = .hidden
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .hidden
    case 2: self = .hex
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .hidden: return 1
    case .hex: return 2
    }
  }

}

#if swift(>=4.2)

extension Bgs_Protocol_LogOption: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct Bgs_Protocol_BGSFieldOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var log: Bgs_Protocol_LogOption {
    get {return _log ?? .hidden}
    set {_log = newValue}
  }
  /// Returns true if `log` has been explicitly set.
  public var hasLog: Bool {return self._log != nil}
  /// Clears the value of `log`. Subsequent reads from it will return its default value.
  public mutating func clearLog() {self._log = nil}

  public var shardKey: Bool {
    get {return _shardKey ?? false}
    set {_shardKey = newValue}
  }
  /// Returns true if `shardKey` has been explicitly set.
  public var hasShardKey: Bool {return self._shardKey != nil}
  /// Clears the value of `shardKey`. Subsequent reads from it will return its default value.
  public mutating func clearShardKey() {self._shardKey = nil}

  public var fanoutKey: Bool {
    get {return _fanoutKey ?? false}
    set {_fanoutKey = newValue}
  }
  /// Returns true if `fanoutKey` has been explicitly set.
  public var hasFanoutKey: Bool {return self._fanoutKey != nil}
  /// Clears the value of `fanoutKey`. Subsequent reads from it will return its default value.
  public mutating func clearFanoutKey() {self._fanoutKey = nil}

  public var clientInstanceKey: Bool {
    get {return _clientInstanceKey ?? false}
    set {_clientInstanceKey = newValue}
  }
  /// Returns true if `clientInstanceKey` has been explicitly set.
  public var hasClientInstanceKey: Bool {return self._clientInstanceKey != nil}
  /// Clears the value of `clientInstanceKey`. Subsequent reads from it will return its default value.
  public mutating func clearClientInstanceKey() {self._clientInstanceKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _log: Bgs_Protocol_LogOption? = nil
  fileprivate var _shardKey: Bool? = nil
  fileprivate var _fanoutKey: Bool? = nil
  fileprivate var _clientInstanceKey: Bool? = nil
}

public struct Bgs_Protocol_FieldRestriction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: OneOf_Type? {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var signed: Bgs_Protocol_SignedFieldRestriction {
    get {
      if case .signed(let v)? = _storage._type {return v}
      return Bgs_Protocol_SignedFieldRestriction()
    }
    set {_uniqueStorage()._type = .signed(newValue)}
  }

  public var unsigned: Bgs_Protocol_UnsignedFieldRestriction {
    get {
      if case .unsigned(let v)? = _storage._type {return v}
      return Bgs_Protocol_UnsignedFieldRestriction()
    }
    set {_uniqueStorage()._type = .unsigned(newValue)}
  }

  public var float: Bgs_Protocol_FloatFieldRestriction {
    get {
      if case .float(let v)? = _storage._type {return v}
      return Bgs_Protocol_FloatFieldRestriction()
    }
    set {_uniqueStorage()._type = .float(newValue)}
  }

  public var string: Bgs_Protocol_StringFieldRestriction {
    get {
      if case .string(let v)? = _storage._type {return v}
      return Bgs_Protocol_StringFieldRestriction()
    }
    set {_uniqueStorage()._type = .string(newValue)}
  }

  public var repeated: Bgs_Protocol_RepeatedFieldRestriction {
    get {
      if case .repeated(let v)? = _storage._type {return v}
      return Bgs_Protocol_RepeatedFieldRestriction()
    }
    set {_uniqueStorage()._type = .repeated(newValue)}
  }

  public var message: Bgs_Protocol_MessageFieldRestriction {
    get {
      if case .message(let v)? = _storage._type {return v}
      return Bgs_Protocol_MessageFieldRestriction()
    }
    set {_uniqueStorage()._type = .message(newValue)}
  }

  public var entityID: Bgs_Protocol_EntityIdRestriction {
    get {
      if case .entityID(let v)? = _storage._type {return v}
      return Bgs_Protocol_EntityIdRestriction()
    }
    set {_uniqueStorage()._type = .entityID(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case signed(Bgs_Protocol_SignedFieldRestriction)
    case unsigned(Bgs_Protocol_UnsignedFieldRestriction)
    case float(Bgs_Protocol_FloatFieldRestriction)
    case string(Bgs_Protocol_StringFieldRestriction)
    case repeated(Bgs_Protocol_RepeatedFieldRestriction)
    case message(Bgs_Protocol_MessageFieldRestriction)
    case entityID(Bgs_Protocol_EntityIdRestriction)

  #if !swift(>=4.1)
    public static func ==(lhs: Bgs_Protocol_FieldRestriction.OneOf_Type, rhs: Bgs_Protocol_FieldRestriction.OneOf_Type) -> Bool {
      switch (lhs, rhs) {
      case (.signed(let l), .signed(let r)): return l == r
      case (.unsigned(let l), .unsigned(let r)): return l == r
      case (.float(let l), .float(let r)): return l == r
      case (.string(let l), .string(let r)): return l == r
      case (.repeated(let l), .repeated(let r)): return l == r
      case (.message(let l), .message(let r)): return l == r
      case (.entityID(let l), .entityID(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Bgs_Protocol_RepeatedFieldRestriction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var size: Bgs_Protocol_UnsignedIntRange {
    get {return _storage._size ?? Bgs_Protocol_UnsignedIntRange()}
    set {_uniqueStorage()._size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  public var hasSize: Bool {return _storage._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  public mutating func clearSize() {_uniqueStorage()._size = nil}

  public var unique: Bool {
    get {return _storage._unique ?? false}
    set {_uniqueStorage()._unique = newValue}
  }
  /// Returns true if `unique` has been explicitly set.
  public var hasUnique: Bool {return _storage._unique != nil}
  /// Clears the value of `unique`. Subsequent reads from it will return its default value.
  public mutating func clearUnique() {_uniqueStorage()._unique = nil}

  public var type: OneOf_Type? {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var signed: Bgs_Protocol_SignedFieldRestriction {
    get {
      if case .signed(let v)? = _storage._type {return v}
      return Bgs_Protocol_SignedFieldRestriction()
    }
    set {_uniqueStorage()._type = .signed(newValue)}
  }

  public var unsigned: Bgs_Protocol_UnsignedFieldRestriction {
    get {
      if case .unsigned(let v)? = _storage._type {return v}
      return Bgs_Protocol_UnsignedFieldRestriction()
    }
    set {_uniqueStorage()._type = .unsigned(newValue)}
  }

  public var float: Bgs_Protocol_FloatFieldRestriction {
    get {
      if case .float(let v)? = _storage._type {return v}
      return Bgs_Protocol_FloatFieldRestriction()
    }
    set {_uniqueStorage()._type = .float(newValue)}
  }

  public var string: Bgs_Protocol_StringFieldRestriction {
    get {
      if case .string(let v)? = _storage._type {return v}
      return Bgs_Protocol_StringFieldRestriction()
    }
    set {_uniqueStorage()._type = .string(newValue)}
  }

  public var entityID: Bgs_Protocol_EntityIdRestriction {
    get {
      if case .entityID(let v)? = _storage._type {return v}
      return Bgs_Protocol_EntityIdRestriction()
    }
    set {_uniqueStorage()._type = .entityID(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case signed(Bgs_Protocol_SignedFieldRestriction)
    case unsigned(Bgs_Protocol_UnsignedFieldRestriction)
    case float(Bgs_Protocol_FloatFieldRestriction)
    case string(Bgs_Protocol_StringFieldRestriction)
    case entityID(Bgs_Protocol_EntityIdRestriction)

  #if !swift(>=4.1)
    public static func ==(lhs: Bgs_Protocol_RepeatedFieldRestriction.OneOf_Type, rhs: Bgs_Protocol_RepeatedFieldRestriction.OneOf_Type) -> Bool {
      switch (lhs, rhs) {
      case (.signed(let l), .signed(let r)): return l == r
      case (.unsigned(let l), .unsigned(let r)): return l == r
      case (.float(let l), .float(let r)): return l == r
      case (.string(let l), .string(let r)): return l == r
      case (.entityID(let l), .entityID(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Bgs_Protocol_SignedFieldRestriction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var limits: Bgs_Protocol_SignedIntRange {
    get {return _storage._limits ?? Bgs_Protocol_SignedIntRange()}
    set {_uniqueStorage()._limits = newValue}
  }
  /// Returns true if `limits` has been explicitly set.
  public var hasLimits: Bool {return _storage._limits != nil}
  /// Clears the value of `limits`. Subsequent reads from it will return its default value.
  public mutating func clearLimits() {_uniqueStorage()._limits = nil}

  public var exclude: [Int64] {
    get {return _storage._exclude}
    set {_uniqueStorage()._exclude = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Bgs_Protocol_UnsignedFieldRestriction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var limits: Bgs_Protocol_UnsignedIntRange {
    get {return _storage._limits ?? Bgs_Protocol_UnsignedIntRange()}
    set {_uniqueStorage()._limits = newValue}
  }
  /// Returns true if `limits` has been explicitly set.
  public var hasLimits: Bool {return _storage._limits != nil}
  /// Clears the value of `limits`. Subsequent reads from it will return its default value.
  public mutating func clearLimits() {_uniqueStorage()._limits = nil}

  public var exclude: [UInt64] {
    get {return _storage._exclude}
    set {_uniqueStorage()._exclude = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Bgs_Protocol_FloatFieldRestriction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var limits: Bgs_Protocol_FloatRange {
    get {return _storage._limits ?? Bgs_Protocol_FloatRange()}
    set {_uniqueStorage()._limits = newValue}
  }
  /// Returns true if `limits` has been explicitly set.
  public var hasLimits: Bool {return _storage._limits != nil}
  /// Clears the value of `limits`. Subsequent reads from it will return its default value.
  public mutating func clearLimits() {_uniqueStorage()._limits = nil}

  public var exclude: [Float] {
    get {return _storage._exclude}
    set {_uniqueStorage()._exclude = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Bgs_Protocol_StringFieldRestriction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var size: Bgs_Protocol_UnsignedIntRange {
    get {return _storage._size ?? Bgs_Protocol_UnsignedIntRange()}
    set {_uniqueStorage()._size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  public var hasSize: Bool {return _storage._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  public mutating func clearSize() {_uniqueStorage()._size = nil}

  public var exclude: [String] {
    get {return _storage._exclude}
    set {_uniqueStorage()._exclude = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Bgs_Protocol_EntityIdRestriction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var needed: Bool {
    get {return _needed ?? false}
    set {_needed = newValue}
  }
  /// Returns true if `needed` has been explicitly set.
  public var hasNeeded: Bool {return self._needed != nil}
  /// Clears the value of `needed`. Subsequent reads from it will return its default value.
  public mutating func clearNeeded() {self._needed = nil}

  public var kind: Bgs_Protocol_EntityIdRestriction.Kind {
    get {return _kind ?? .any}
    set {_kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  public var hasKind: Bool {return self._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  public mutating func clearKind() {self._kind = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Kind: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case any // = 0
    case account // = 1
    case gameAccount // = 2
    case accountOrGameAccount // = 3
    case service // = 4
    case channel // = 5

    public init() {
      self = .any
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .any
      case 1: self = .account
      case 2: self = .gameAccount
      case 3: self = .accountOrGameAccount
      case 4: self = .service
      case 5: self = .channel
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .any: return 0
      case .account: return 1
      case .gameAccount: return 2
      case .accountOrGameAccount: return 3
      case .service: return 4
      case .channel: return 5
      }
    }

  }

  public init() {}

  fileprivate var _needed: Bool? = nil
  fileprivate var _kind: Bgs_Protocol_EntityIdRestriction.Kind? = nil
}

#if swift(>=4.2)

extension Bgs_Protocol_EntityIdRestriction.Kind: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct Bgs_Protocol_MessageFieldRestriction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var needed: Bool {
    get {return _needed ?? false}
    set {_needed = newValue}
  }
  /// Returns true if `needed` has been explicitly set.
  public var hasNeeded: Bool {return self._needed != nil}
  /// Clears the value of `needed`. Subsequent reads from it will return its default value.
  public mutating func clearNeeded() {self._needed = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _needed: Bool? = nil
}

// MARK: - Extension support defined in field_options.proto.

extension SwiftProtobuf.Google_Protobuf_FieldOptions {

  public var Bgs_Protocol_fieldOptions: Bgs_Protocol_BGSFieldOptions {
    get {return getExtensionValue(ext: Bgs_Protocol_Extensions_field_options) ?? Bgs_Protocol_BGSFieldOptions()}
    set {setExtensionValue(ext: Bgs_Protocol_Extensions_field_options, value: newValue)}
  }
  /// Returns true if extension `Bgs_Protocol_Extensions_field_options`
  /// has been explicitly set.
  public var hasBgs_Protocol_fieldOptions: Bool {
    return hasExtensionValue(ext: Bgs_Protocol_Extensions_field_options)
  }
  /// Clears the value of extension `Bgs_Protocol_Extensions_field_options`.
  /// Subsequent reads from it will return its default value.
  public mutating func clearBgs_Protocol_fieldOptions() {
    clearExtensionValue(ext: Bgs_Protocol_Extensions_field_options)
  }

  public var Bgs_Protocol_valid: Bgs_Protocol_FieldRestriction {
    get {return getExtensionValue(ext: Bgs_Protocol_Extensions_valid) ?? Bgs_Protocol_FieldRestriction()}
    set {setExtensionValue(ext: Bgs_Protocol_Extensions_valid, value: newValue)}
  }
  /// Returns true if extension `Bgs_Protocol_Extensions_valid`
  /// has been explicitly set.
  public var hasBgs_Protocol_valid: Bool {
    return hasExtensionValue(ext: Bgs_Protocol_Extensions_valid)
  }
  /// Clears the value of extension `Bgs_Protocol_Extensions_valid`.
  /// Subsequent reads from it will return its default value.
  public mutating func clearBgs_Protocol_valid() {
    clearExtensionValue(ext: Bgs_Protocol_Extensions_valid)
  }

}

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
public let Bgs_Protocol_FieldOptions_Extensions: SwiftProtobuf.SimpleExtensionMap = [
  Bgs_Protocol_Extensions_field_options,
  Bgs_Protocol_Extensions_valid
]

let Bgs_Protocol_Extensions_field_options = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<Bgs_Protocol_BGSFieldOptions>, SwiftProtobuf.Google_Protobuf_FieldOptions>(
  _protobuf_fieldNumber: 90000,
  fieldName: "bgs.protocol.field_options"
)

let Bgs_Protocol_Extensions_valid = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<Bgs_Protocol_FieldRestriction>, SwiftProtobuf.Google_Protobuf_FieldOptions>(
  _protobuf_fieldNumber: 90001,
  fieldName: "bgs.protocol.valid"
)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bgs.protocol"

extension Bgs_Protocol_LogOption: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "HIDDEN"),
    2: .same(proto: "HEX"),
  ]
}

extension Bgs_Protocol_BGSFieldOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BGSFieldOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "log"),
    2: .standard(proto: "shard_key"),
    3: .standard(proto: "fanout_key"),
    4: .standard(proto: "client_instance_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._log)
      case 2: try decoder.decodeSingularBoolField(value: &self._shardKey)
      case 3: try decoder.decodeSingularBoolField(value: &self._fanoutKey)
      case 4: try decoder.decodeSingularBoolField(value: &self._clientInstanceKey)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._log {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._shardKey {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    if let v = self._fanoutKey {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._clientInstanceKey {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_BGSFieldOptions, rhs: Bgs_Protocol_BGSFieldOptions) -> Bool {
    if lhs._log != rhs._log {return false}
    if lhs._shardKey != rhs._shardKey {return false}
    if lhs._fanoutKey != rhs._fanoutKey {return false}
    if lhs._clientInstanceKey != rhs._clientInstanceKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_FieldRestriction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FieldRestriction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signed"),
    2: .same(proto: "unsigned"),
    3: .same(proto: "float"),
    4: .same(proto: "string"),
    5: .same(proto: "repeated"),
    6: .same(proto: "message"),
    7: .standard(proto: "entity_id"),
  ]

  fileprivate class _StorageClass {
    var _type: Bgs_Protocol_FieldRestriction.OneOf_Type?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Bgs_Protocol_SignedFieldRestriction?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .signed(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .signed(v)}
        case 2:
          var v: Bgs_Protocol_UnsignedFieldRestriction?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .unsigned(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .unsigned(v)}
        case 3:
          var v: Bgs_Protocol_FloatFieldRestriction?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .float(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .float(v)}
        case 4:
          var v: Bgs_Protocol_StringFieldRestriction?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .string(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .string(v)}
        case 5:
          var v: Bgs_Protocol_RepeatedFieldRestriction?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .repeated(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .repeated(v)}
        case 6:
          var v: Bgs_Protocol_MessageFieldRestriction?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .message(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .message(v)}
        case 7:
          var v: Bgs_Protocol_EntityIdRestriction?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .entityID(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .entityID(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._type {
      case .signed(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .unsigned(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .float(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .string(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .repeated(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .message(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .entityID(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_FieldRestriction, rhs: Bgs_Protocol_FieldRestriction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_RepeatedFieldRestriction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RepeatedFieldRestriction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
    2: .same(proto: "unique"),
    3: .same(proto: "signed"),
    4: .same(proto: "unsigned"),
    5: .same(proto: "float"),
    6: .same(proto: "string"),
    7: .standard(proto: "entity_id"),
  ]

  fileprivate class _StorageClass {
    var _size: Bgs_Protocol_UnsignedIntRange? = nil
    var _unique: Bool? = nil
    var _type: Bgs_Protocol_RepeatedFieldRestriction.OneOf_Type?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _size = source._size
      _unique = source._unique
      _type = source._type
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._size)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._unique)
        case 3:
          var v: Bgs_Protocol_SignedFieldRestriction?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .signed(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .signed(v)}
        case 4:
          var v: Bgs_Protocol_UnsignedFieldRestriction?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .unsigned(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .unsigned(v)}
        case 5:
          var v: Bgs_Protocol_FloatFieldRestriction?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .float(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .float(v)}
        case 6:
          var v: Bgs_Protocol_StringFieldRestriction?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .string(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .string(v)}
        case 7:
          var v: Bgs_Protocol_EntityIdRestriction?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .entityID(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .entityID(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._size {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._unique {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      }
      switch _storage._type {
      case .signed(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .unsigned(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .float(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .string(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .entityID(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_RepeatedFieldRestriction, rhs: Bgs_Protocol_RepeatedFieldRestriction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._size != rhs_storage._size {return false}
        if _storage._unique != rhs_storage._unique {return false}
        if _storage._type != rhs_storage._type {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_SignedFieldRestriction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignedFieldRestriction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "limits"),
    2: .same(proto: "exclude"),
  ]

  fileprivate class _StorageClass {
    var _limits: Bgs_Protocol_SignedIntRange? = nil
    var _exclude: [Int64] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _limits = source._limits
      _exclude = source._exclude
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._limits)
        case 2: try decoder.decodeRepeatedSInt64Field(value: &_storage._exclude)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._limits {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._exclude.isEmpty {
        try visitor.visitRepeatedSInt64Field(value: _storage._exclude, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_SignedFieldRestriction, rhs: Bgs_Protocol_SignedFieldRestriction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._limits != rhs_storage._limits {return false}
        if _storage._exclude != rhs_storage._exclude {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_UnsignedFieldRestriction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnsignedFieldRestriction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "limits"),
    2: .same(proto: "exclude"),
  ]

  fileprivate class _StorageClass {
    var _limits: Bgs_Protocol_UnsignedIntRange? = nil
    var _exclude: [UInt64] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _limits = source._limits
      _exclude = source._exclude
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._limits)
        case 2: try decoder.decodeRepeatedUInt64Field(value: &_storage._exclude)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._limits {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._exclude.isEmpty {
        try visitor.visitRepeatedUInt64Field(value: _storage._exclude, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_UnsignedFieldRestriction, rhs: Bgs_Protocol_UnsignedFieldRestriction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._limits != rhs_storage._limits {return false}
        if _storage._exclude != rhs_storage._exclude {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_FloatFieldRestriction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FloatFieldRestriction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "limits"),
    2: .same(proto: "exclude"),
  ]

  fileprivate class _StorageClass {
    var _limits: Bgs_Protocol_FloatRange? = nil
    var _exclude: [Float] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _limits = source._limits
      _exclude = source._exclude
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._limits)
        case 2: try decoder.decodeRepeatedFloatField(value: &_storage._exclude)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._limits {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._exclude.isEmpty {
        try visitor.visitRepeatedFloatField(value: _storage._exclude, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_FloatFieldRestriction, rhs: Bgs_Protocol_FloatFieldRestriction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._limits != rhs_storage._limits {return false}
        if _storage._exclude != rhs_storage._exclude {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_StringFieldRestriction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StringFieldRestriction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
    2: .same(proto: "exclude"),
  ]

  fileprivate class _StorageClass {
    var _size: Bgs_Protocol_UnsignedIntRange? = nil
    var _exclude: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _size = source._size
      _exclude = source._exclude
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._size)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._exclude)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._size {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._exclude.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._exclude, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_StringFieldRestriction, rhs: Bgs_Protocol_StringFieldRestriction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._size != rhs_storage._size {return false}
        if _storage._exclude != rhs_storage._exclude {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_EntityIdRestriction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EntityIdRestriction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "needed"),
    2: .same(proto: "kind"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self._needed)
      case 2: try decoder.decodeSingularEnumField(value: &self._kind)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._needed {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    if let v = self._kind {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_EntityIdRestriction, rhs: Bgs_Protocol_EntityIdRestriction) -> Bool {
    if lhs._needed != rhs._needed {return false}
    if lhs._kind != rhs._kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bgs_Protocol_EntityIdRestriction.Kind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ANY"),
    1: .same(proto: "ACCOUNT"),
    2: .same(proto: "GAME_ACCOUNT"),
    3: .same(proto: "ACCOUNT_OR_GAME_ACCOUNT"),
    4: .same(proto: "SERVICE"),
    5: .same(proto: "CHANNEL"),
  ]
}

extension Bgs_Protocol_MessageFieldRestriction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageFieldRestriction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "needed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self._needed)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._needed {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bgs_Protocol_MessageFieldRestriction, rhs: Bgs_Protocol_MessageFieldRestriction) -> Bool {
    if lhs._needed != rhs._needed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
